// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package gtfsdb

import (
	"context"
	"database/sql"
	"strings"
)

const clearAgencies = `-- name: ClearAgencies :exec
DELETE FROM agencies
`

func (q *Queries) ClearAgencies(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearAgenciesStmt, clearAgencies)
	return err
}

const clearCalendar = `-- name: ClearCalendar :exec
DELETE FROM calendar
`

func (q *Queries) ClearCalendar(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearCalendarStmt, clearCalendar)
	return err
}

const clearRoutes = `-- name: ClearRoutes :exec
DELETE FROM routes
`

func (q *Queries) ClearRoutes(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearRoutesStmt, clearRoutes)
	return err
}

const clearShapes = `-- name: ClearShapes :exec
DELETE FROM shapes
`

func (q *Queries) ClearShapes(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearShapesStmt, clearShapes)
	return err
}

const clearStopTimes = `-- name: ClearStopTimes :exec
DELETE FROM stop_times
`

func (q *Queries) ClearStopTimes(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearStopTimesStmt, clearStopTimes)
	return err
}

const clearStops = `-- name: ClearStops :exec
DELETE FROM stops
`

func (q *Queries) ClearStops(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearStopsStmt, clearStops)
	return err
}

const clearTrips = `-- name: ClearTrips :exec
DELETE FROM trips
`

func (q *Queries) ClearTrips(ctx context.Context) error {
	_, err := q.exec(ctx, q.clearTripsStmt, clearTrips)
	return err
}

const createAgency = `-- name: CreateAgency :one
INSERT
OR REPLACE INTO agencies (
    id,
    name,
    url,
    timezone,
    lang,
    phone,
    fare_url,
    email
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, name, url, timezone, lang, phone, fare_url, email
`

type CreateAgencyParams struct {
	ID       string
	Name     string
	Url      string
	Timezone string
	Lang     sql.NullString
	Phone    sql.NullString
	FareUrl  sql.NullString
	Email    sql.NullString
}

func (q *Queries) CreateAgency(ctx context.Context, arg CreateAgencyParams) (Agency, error) {
	row := q.queryRow(ctx, q.createAgencyStmt, createAgency,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.Timezone,
		arg.Lang,
		arg.Phone,
		arg.FareUrl,
		arg.Email,
	)
	var i Agency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Timezone,
		&i.Lang,
		&i.Phone,
		&i.FareUrl,
		&i.Email,
	)
	return i, err
}

const createCalendar = `-- name: CreateCalendar :one
INSERT
OR REPLACE INTO calendar (
    id,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday,
    sunday,
    start_date,
    end_date
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, start_date, end_date
`

type CreateCalendarParams struct {
	ID        string
	Monday    int64
	Tuesday   int64
	Wednesday int64
	Thursday  int64
	Friday    int64
	Saturday  int64
	Sunday    int64
	StartDate string
	EndDate   string
}

func (q *Queries) CreateCalendar(ctx context.Context, arg CreateCalendarParams) (Calendar, error) {
	row := q.queryRow(ctx, q.createCalendarStmt, createCalendar,
		arg.ID,
		arg.Monday,
		arg.Tuesday,
		arg.Wednesday,
		arg.Thursday,
		arg.Friday,
		arg.Saturday,
		arg.Sunday,
		arg.StartDate,
		arg.EndDate,
	)
	var i Calendar
	err := row.Scan(
		&i.ID,
		&i.Monday,
		&i.Tuesday,
		&i.Wednesday,
		&i.Thursday,
		&i.Friday,
		&i.Saturday,
		&i.Sunday,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const createCalendarDate = `-- name: CreateCalendarDate :one
INSERT
OR REPLACE INTO calendar_dates(service_id, date, exception_type)
VALUES (?, ?, ?) RETURNING service_id, date, exception_type
`

type CreateCalendarDateParams struct {
	ServiceID     string
	Date          string
	ExceptionType int64
}

func (q *Queries) CreateCalendarDate(ctx context.Context, arg CreateCalendarDateParams) (CalendarDate, error) {
	row := q.queryRow(ctx, q.createCalendarDateStmt, createCalendarDate, arg.ServiceID, arg.Date, arg.ExceptionType)
	var i CalendarDate
	err := row.Scan(&i.ServiceID, &i.Date, &i.ExceptionType)
	return i, err
}

const createRoute = `-- name: CreateRoute :one
INSERT
OR REPLACE INTO routes (
    id,
    agency_id,
    short_name,
    long_name,
    desc,
    type,
    url,
    color,
    text_color,
    continuous_pickup,
    continuous_drop_off
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, agency_id, short_name, long_name, "desc", type, url, color, text_color, continuous_pickup, continuous_drop_off
`

type CreateRouteParams struct {
	ID                string
	AgencyID          string
	ShortName         sql.NullString
	LongName          sql.NullString
	Desc              sql.NullString
	Type              int64
	Url               sql.NullString
	Color             sql.NullString
	TextColor         sql.NullString
	ContinuousPickup  sql.NullInt64
	ContinuousDropOff sql.NullInt64
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (Route, error) {
	row := q.queryRow(ctx, q.createRouteStmt, createRoute,
		arg.ID,
		arg.AgencyID,
		arg.ShortName,
		arg.LongName,
		arg.Desc,
		arg.Type,
		arg.Url,
		arg.Color,
		arg.TextColor,
		arg.ContinuousPickup,
		arg.ContinuousDropOff,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.AgencyID,
		&i.ShortName,
		&i.LongName,
		&i.Desc,
		&i.Type,
		&i.Url,
		&i.Color,
		&i.TextColor,
		&i.ContinuousPickup,
		&i.ContinuousDropOff,
	)
	return i, err
}

const createShape = `-- name: CreateShape :one
INSERT
OR REPLACE INTO shapes (shape_id, lat, lon, shape_pt_sequence)
VALUES
    (?, ?, ?, ?) RETURNING id, shape_id, lat, lon, shape_pt_sequence
`

type CreateShapeParams struct {
	ShapeID         string
	Lat             float64
	Lon             float64
	ShapePtSequence int64
}

func (q *Queries) CreateShape(ctx context.Context, arg CreateShapeParams) (Shape, error) {
	row := q.queryRow(ctx, q.createShapeStmt, createShape,
		arg.ShapeID,
		arg.Lat,
		arg.Lon,
		arg.ShapePtSequence,
	)
	var i Shape
	err := row.Scan(
		&i.ID,
		&i.ShapeID,
		&i.Lat,
		&i.Lon,
		&i.ShapePtSequence,
	)
	return i, err
}

const createStop = `-- name: CreateStop :one
INSERT
OR REPLACE INTO stops (
    id,
    code,
    name,
    desc,
    lat,
    lon,
    zone_id,
    url,
    location_type,
    timezone,
    wheelchair_boarding,
    platform_code
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, code, name, "desc", lat, lon, zone_id, url, location_type, timezone, wheelchair_boarding, platform_code
`

type CreateStopParams struct {
	ID                 string
	Code               sql.NullString
	Name               sql.NullString
	Desc               sql.NullString
	Lat                float64
	Lon                float64
	ZoneID             sql.NullString
	Url                sql.NullString
	LocationType       sql.NullInt64
	Timezone           sql.NullString
	WheelchairBoarding sql.NullInt64
	PlatformCode       sql.NullString
}

func (q *Queries) CreateStop(ctx context.Context, arg CreateStopParams) (Stop, error) {
	row := q.queryRow(ctx, q.createStopStmt, createStop,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.Desc,
		arg.Lat,
		arg.Lon,
		arg.ZoneID,
		arg.Url,
		arg.LocationType,
		arg.Timezone,
		arg.WheelchairBoarding,
		arg.PlatformCode,
	)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Desc,
		&i.Lat,
		&i.Lon,
		&i.ZoneID,
		&i.Url,
		&i.LocationType,
		&i.Timezone,
		&i.WheelchairBoarding,
		&i.PlatformCode,
	)
	return i, err
}

const createStopTime = `-- name: CreateStopTime :one
INSERT
OR REPLACE INTO stop_times (
    trip_id,
    arrival_time,
    departure_time,
    stop_id,
    stop_sequence,
    stop_headsign,
    pickup_type,
    drop_off_type,
    timepoint
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING trip_id, arrival_time, departure_time, stop_id, stop_sequence, stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint
`

type CreateStopTimeParams struct {
	TripID        string
	ArrivalTime   int64
	DepartureTime int64
	StopID        string
	StopSequence  int64
	StopHeadsign  sql.NullString
	PickupType    sql.NullInt64
	DropOffType   sql.NullInt64
	Timepoint     sql.NullInt64
}

func (q *Queries) CreateStopTime(ctx context.Context, arg CreateStopTimeParams) (StopTime, error) {
	row := q.queryRow(ctx, q.createStopTimeStmt, createStopTime,
		arg.TripID,
		arg.ArrivalTime,
		arg.DepartureTime,
		arg.StopID,
		arg.StopSequence,
		arg.StopHeadsign,
		arg.PickupType,
		arg.DropOffType,
		arg.Timepoint,
	)
	var i StopTime
	err := row.Scan(
		&i.TripID,
		&i.ArrivalTime,
		&i.DepartureTime,
		&i.StopID,
		&i.StopSequence,
		&i.StopHeadsign,
		&i.PickupType,
		&i.DropOffType,
		&i.ShapeDistTraveled,
		&i.Timepoint,
	)
	return i, err
}

const createTrip = `-- name: CreateTrip :one
INSERT
OR REPLACE INTO trips (
    id,
    route_id,
    service_id,
    trip_headsign,
    trip_short_name,
    direction_id,
    block_id,
    shape_id,
    wheelchair_accessible,
    bikes_allowed
)
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
`

type CreateTripParams struct {
	ID                   string
	RouteID              string
	ServiceID            string
	TripHeadsign         sql.NullString
	TripShortName        sql.NullString
	DirectionID          sql.NullInt64
	BlockID              sql.NullString
	ShapeID              sql.NullString
	WheelchairAccessible sql.NullInt64
	BikesAllowed         sql.NullInt64
}

func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (Trip, error) {
	row := q.queryRow(ctx, q.createTripStmt, createTrip,
		arg.ID,
		arg.RouteID,
		arg.ServiceID,
		arg.TripHeadsign,
		arg.TripShortName,
		arg.DirectionID,
		arg.BlockID,
		arg.ShapeID,
		arg.WheelchairAccessible,
		arg.BikesAllowed,
	)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.ServiceID,
		&i.TripHeadsign,
		&i.TripShortName,
		&i.DirectionID,
		&i.BlockID,
		&i.ShapeID,
		&i.WheelchairAccessible,
		&i.BikesAllowed,
	)
	return i, err
}

const getActiveServiceIDsForDate = `-- name: GetActiveServiceIDsForDate :many
WITH formatted_date AS (
    SELECT STRFTIME('%w', SUBSTR(?1, 1, 4) || '-' || SUBSTR(?1, 5, 2) || '-' || SUBSTR(?1, 7, 2)) AS weekday
)
SELECT DISTINCT c.id AS service_id
FROM calendar c, formatted_date fd
WHERE c.start_date <= ?1
  AND c.end_date >= ?1
  AND (
    (fd.weekday = '0' AND c.sunday = 1) OR
    (fd.weekday = '1' AND c.monday = 1) OR
    (fd.weekday = '2' AND c.tuesday = 1) OR
    (fd.weekday = '3' AND c.wednesday = 1) OR
    (fd.weekday = '4' AND c.thursday = 1) OR
    (fd.weekday = '5' AND c.friday = 1) OR
    (fd.weekday = '6' AND c.saturday = 1)
    )
UNION
SELECT DISTINCT service_id
FROM calendar_dates
WHERE date = ?1
  AND exception_type = 1
`

func (q *Queries) GetActiveServiceIDsForDate(ctx context.Context, targetDate interface{}) ([]string, error) {
	rows, err := q.query(ctx, q.getActiveServiceIDsForDateStmt, getActiveServiceIDsForDate, targetDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var service_id string
		if err := rows.Scan(&service_id); err != nil {
			return nil, err
		}
		items = append(items, service_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgenciesForStops = `-- name: GetAgenciesForStops :many
SELECT DISTINCT
    a.id,
    a.name,
    a.url,
    a.timezone,
    a.lang,
    a.phone,
    a.fare_url,
    a.email,
    stop_times.stop_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
    JOIN agencies a ON routes.agency_id = a.id
WHERE
    stop_times.stop_id IN (/*SLICE:stop_ids*/?)
`

type GetAgenciesForStopsRow struct {
	ID       string
	Name     string
	Url      string
	Timezone string
	Lang     sql.NullString
	Phone    sql.NullString
	FareUrl  sql.NullString
	Email    sql.NullString
	StopID   string
}

func (q *Queries) GetAgenciesForStops(ctx context.Context, stopIds []string) ([]GetAgenciesForStopsRow, error) {
	query := getAgenciesForStops
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAgenciesForStopsRow
	for rows.Next() {
		var i GetAgenciesForStopsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Timezone,
			&i.Lang,
			&i.Phone,
			&i.FareUrl,
			&i.Email,
			&i.StopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgency = `-- name: GetAgency :one
SELECT
    id, name, url, timezone, lang, phone, fare_url, email
FROM
    agencies
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetAgency(ctx context.Context, id string) (Agency, error) {
	row := q.queryRow(ctx, q.getAgencyStmt, getAgency, id)
	var i Agency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Timezone,
		&i.Lang,
		&i.Phone,
		&i.FareUrl,
		&i.Email,
	)
	return i, err
}

const getAgencyForStop = `-- name: GetAgencyForStop :one
SELECT DISTINCT
    a.id,
    a.name,
    a.url,
    a.timezone,
    a.lang,
    a.phone,
    a.fare_url,
    a.email
FROM
    agencies a
    JOIN routes r ON a.id = r.agency_id
    JOIN trips t ON r.id = t.route_id
    JOIN stop_times st ON t.id = st.trip_id
WHERE
    st.stop_id = ?
ORDER BY
    a.id
LIMIT
    1
`

func (q *Queries) GetAgencyForStop(ctx context.Context, stopID string) (Agency, error) {
	row := q.queryRow(ctx, q.getAgencyForStopStmt, getAgencyForStop, stopID)
	var i Agency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Timezone,
		&i.Lang,
		&i.Phone,
		&i.FareUrl,
		&i.Email,
	)
	return i, err
}

const getAllShapes = `-- name: GetAllShapes :many
SELECT
    id, shape_id, lat, lon, shape_pt_sequence
FROM
    shapes
`

func (q *Queries) GetAllShapes(ctx context.Context) ([]Shape, error) {
	rows, err := q.query(ctx, q.getAllShapesStmt, getAllShapes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shape
	for rows.Next() {
		var i Shape
		if err := rows.Scan(
			&i.ID,
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTripsForRoute = `-- name: GetAllTripsForRoute :many
SELECT DISTINCT id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM trips t
WHERE t.route_id = ?1
ORDER BY t.direction_id, t.trip_headsign
`

func (q *Queries) GetAllTripsForRoute(ctx context.Context, routeID string) ([]Trip, error) {
	rows, err := q.query(ctx, q.getAllTripsForRouteStmt, getAllTripsForRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockIDByTripID = `-- name: GetBlockIDByTripID :one
SELECT
    block_id
FROM
    trips
WHERE
    id = ?
`

func (q *Queries) GetBlockIDByTripID(ctx context.Context, id string) (sql.NullString, error) {
	row := q.queryRow(ctx, q.getBlockIDByTripIDStmt, getBlockIDByTripID, id)
	var block_id sql.NullString
	err := row.Scan(&block_id)
	return block_id, err
}

const getCalendarByServiceID = `-- name: GetCalendarByServiceID :one
SELECT
    id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, start_date, end_date
FROM
    calendar
WHERE
    id = ?
`

func (q *Queries) GetCalendarByServiceID(ctx context.Context, id string) (Calendar, error) {
	row := q.queryRow(ctx, q.getCalendarByServiceIDStmt, getCalendarByServiceID, id)
	var i Calendar
	err := row.Scan(
		&i.ID,
		&i.Monday,
		&i.Tuesday,
		&i.Wednesday,
		&i.Thursday,
		&i.Friday,
		&i.Saturday,
		&i.Sunday,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getCalendarDateExceptionsForServiceID = `-- name: GetCalendarDateExceptionsForServiceID :many
SELECT
    service_id, date, exception_type
FROM
    calendar_dates
WHERE
    service_id = ?
`

func (q *Queries) GetCalendarDateExceptionsForServiceID(ctx context.Context, serviceID string) ([]CalendarDate, error) {
	rows, err := q.query(ctx, q.getCalendarDateExceptionsForServiceIDStmt, getCalendarDateExceptionsForServiceID, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CalendarDate
	for rows.Next() {
		var i CalendarDate
		if err := rows.Scan(&i.ServiceID, &i.Date, &i.ExceptionType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockDetails = `-- name: GetBlockDetails :many

SELECT
    t.service_id,
    t.id as trip_id,
    t.route_id,
    st.arrival_time,
    st.departure_time,
    st.stop_id,
    st.stop_sequence,
    st.pickup_type,
    st.drop_off_type,
    s.lat,
    s.lon
FROM
    trips t
        JOIN
    stop_times st ON t.id = st.trip_id
        JOIN
    stops s ON st.stop_id = s.id
WHERE
    t.block_id = ?
ORDER BY
    t.id, st.stop_sequence
`

type GetBlockDetailsRow struct {
	ServiceID     string
	TripID        string
	RouteID       string
	ArrivalTime   int64
	DepartureTime int64
	StopID        string
	StopSequence  int64
	PickupType    sql.NullInt64
	DropOffType   sql.NullInt64
	Lat           float64
	Lon           float64
}

func (q *Queries) GetBlockDetails(ctx context.Context, blockID sql.NullString) ([]GetBlockDetailsRow, error) {
	rows, err := q.query(ctx, q.getBlockDetailsStmt, getBlockDetails, blockID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockDetailsRow
	for rows.Next() {
		var i GetBlockDetailsRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.TripID,
			&i.RouteID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.PickupType,
			&i.DropOffType,
			&i.Lat,
			&i.Lon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImportMetadata = `-- name: GetImportMetadata :one
SELECT
    id, file_hash, import_time, file_source
FROM
    import_metadata
WHERE
    id = 1
`

func (q *Queries) GetImportMetadata(ctx context.Context) (ImportMetadatum, error) {
	row := q.queryRow(ctx, q.getImportMetadataStmt, getImportMetadata)
	var i ImportMetadatum
	err := row.Scan(
		&i.ID,
		&i.FileHash,
		&i.ImportTime,
		&i.FileSource,
	)
	return i, err
}

const getOrderedStopIDsForTrip = `-- name: GetOrderedStopIDsForTrip :many
SELECT stop_id
FROM stop_times
WHERE trip_id = ?
ORDER BY stop_sequence
`

func (q *Queries) GetOrderedStopIDsForTrip(ctx context.Context, tripID string) ([]string, error) {
	rows, err := q.query(ctx, q.getOrderedStopIDsForTripStmt, getOrderedStopIDsForTrip, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stop_id string
		if err := rows.Scan(&stop_id); err != nil {
			return nil, err
		}
		items = append(items, stop_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoute = `-- name: GetRoute :one
SELECT
    id, agency_id, short_name, long_name, "desc", type, url, color, text_color, continuous_pickup, continuous_drop_off
FROM
    routes
WHERE
    id = ?
`

func (q *Queries) GetRoute(ctx context.Context, id string) (Route, error) {
	row := q.queryRow(ctx, q.getRouteStmt, getRoute, id)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.AgencyID,
		&i.ShortName,
		&i.LongName,
		&i.Desc,
		&i.Type,
		&i.Url,
		&i.Color,
		&i.TextColor,
		&i.ContinuousPickup,
		&i.ContinuousDropOff,
	)
	return i, err
}

const getRouteIDsForAgency = `-- name: GetRouteIDsForAgency :many
SELECT
    r.id
FROM
    routes r
    JOIN agencies a ON r.agency_id = a.id
WHERE
    a.id = ?
`

func (q *Queries) GetRouteIDsForAgency(ctx context.Context, id string) ([]string, error) {
	rows, err := q.query(ctx, q.getRouteIDsForAgencyStmt, getRouteIDsForAgency, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRouteIDsForStop = `-- name: GetRouteIDsForStop :many
SELECT DISTINCT
    (routes.agency_id || '_' || routes.id) AS route_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id = ?
`

func (q *Queries) GetRouteIDsForStop(ctx context.Context, stopID string) ([]interface{}, error) {
	rows, err := q.query(ctx, q.getRouteIDsForStopStmt, getRouteIDsForStop, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var route_id interface{}
		if err := rows.Scan(&route_id); err != nil {
			return nil, err
		}
		items = append(items, route_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRouteIDsForStops = `-- name: GetRouteIDsForStops :many
SELECT DISTINCT
    routes.agency_id || '_' || routes.id AS route_id,
    stop_times.stop_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id IN (/*SLICE:stop_ids*/?)
`

type GetRouteIDsForStopsRow struct {
	RouteID interface{}
	StopID  string
}

func (q *Queries) GetRouteIDsForStops(ctx context.Context, stopIds []string) ([]GetRouteIDsForStopsRow, error) {
	query := getRouteIDsForStops
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRouteIDsForStopsRow
	for rows.Next() {
		var i GetRouteIDsForStopsRow
		if err := rows.Scan(&i.RouteID, &i.StopID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesForStop = `-- name: GetRoutesForStop :many
SELECT DISTINCT
    routes.id, routes.agency_id, routes.short_name, routes.long_name, routes."desc", routes.type, routes.url, routes.color, routes.text_color, routes.continuous_pickup, routes.continuous_drop_off
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id = ?
`

func (q *Queries) GetRoutesForStop(ctx context.Context, stopID string) ([]Route, error) {
	rows, err := q.query(ctx, q.getRoutesForStopStmt, getRoutesForStop, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.AgencyID,
			&i.ShortName,
			&i.LongName,
			&i.Desc,
			&i.Type,
			&i.Url,
			&i.Color,
			&i.TextColor,
			&i.ContinuousPickup,
			&i.ContinuousDropOff,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesForStops = `-- name: GetRoutesForStops :many

SELECT DISTINCT
    routes.id, routes.agency_id, routes.short_name, routes.long_name, routes."desc", routes.type, routes.url, routes.color, routes.text_color, routes.continuous_pickup, routes.continuous_drop_off,
    stop_times.stop_id
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
WHERE
    stop_times.stop_id IN (/*SLICE:stop_ids*/?)
`

type GetRoutesForStopsRow struct {
	ID                string
	AgencyID          string
	ShortName         sql.NullString
	LongName          sql.NullString
	Desc              sql.NullString
	Type              int64
	Url               sql.NullString
	Color             sql.NullString
	TextColor         sql.NullString
	ContinuousPickup  sql.NullInt64
	ContinuousDropOff sql.NullInt64
	StopID            string
}

// Batch queries to solve N+1 problems
func (q *Queries) GetRoutesForStops(ctx context.Context, stopIds []string) ([]GetRoutesForStopsRow, error) {
	query := getRoutesForStops
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoutesForStopsRow
	for rows.Next() {
		var i GetRoutesForStopsRow
		if err := rows.Scan(
			&i.ID,
			&i.AgencyID,
			&i.ShortName,
			&i.LongName,
			&i.Desc,
			&i.Type,
			&i.Url,
			&i.Color,
			&i.TextColor,
			&i.ContinuousPickup,
			&i.ContinuousDropOff,
			&i.StopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleForStop = `-- name: GetScheduleForStop :many
SELECT
    st.trip_id,
    st.arrival_time,
    st.departure_time,
    st.stop_headsign,
    t.service_id,
    t.route_id,
    t.trip_headsign,
    r.id as route_id,
    r.agency_id
FROM
    stop_times st
    JOIN trips t ON st.trip_id = t.id
    JOIN routes r ON t.route_id = r.id
WHERE
    st.stop_id = ?
ORDER BY
    r.id, st.arrival_time
`

type GetScheduleForStopRow struct {
	TripID        string
	ArrivalTime   int64
	DepartureTime int64
	StopHeadsign  sql.NullString
	ServiceID     string
	RouteID       string
	TripHeadsign  sql.NullString
	RouteID_2     string
	AgencyID      string
}

func (q *Queries) GetScheduleForStop(ctx context.Context, stopID string) ([]GetScheduleForStopRow, error) {
	rows, err := q.query(ctx, q.getScheduleForStopStmt, getScheduleForStop, stopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScheduleForStopRow
	for rows.Next() {
		var i GetScheduleForStopRow
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopHeadsign,
			&i.ServiceID,
			&i.RouteID,
			&i.TripHeadsign,
			&i.RouteID_2,
			&i.AgencyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapeByID = `-- name: GetShapeByID :many
SELECT
    id, shape_id, lat, lon, shape_pt_sequence
FROM
    shapes
WHERE
    shape_id = ?
`

func (q *Queries) GetShapeByID(ctx context.Context, shapeID string) ([]Shape, error) {
	rows, err := q.query(ctx, q.getShapeByIDStmt, getShapeByID, shapeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shape
	for rows.Next() {
		var i Shape
		if err := rows.Scan(
			&i.ID,
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapePointsByTripID = `-- name: GetShapePointsByTripID :many
SELECT
    s.id,
    s.shape_id,
    s.lat,
    s.lon,
    s.shape_pt_sequence
FROM
    shapes s
    JOIN trips t ON t.shape_id = s.shape_id
WHERE
    t.id = ?
ORDER BY
    s.shape_pt_sequence ASC
`

func (q *Queries) GetShapePointsByTripID(ctx context.Context, id string) ([]Shape, error) {
	rows, err := q.query(ctx, q.getShapePointsByTripIDStmt, getShapePointsByTripID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shape
	for rows.Next() {
		var i Shape
		if err := rows.Scan(
			&i.ID,
			&i.ShapeID,
			&i.Lat,
			&i.Lon,
			&i.ShapePtSequence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShapesGroupedByTripHeadSign = `-- name: GetShapesGroupedByTripHeadSign :many
SELECT DISTINCT s.lat, s.lon, s.shape_pt_sequence
FROM shapes s
         JOIN (
    SELECT shape_id
    FROM trips
    WHERE route_id = ?1
      AND trip_headsign = ?2
      AND shape_id IS NOT NULL
    LIMIT 1
) t ON s.shape_id = t.shape_id
ORDER BY s.shape_pt_sequence
`

type GetShapesGroupedByTripHeadSignParams struct {
	RouteID      string
	TripHeadsign sql.NullString
}

type GetShapesGroupedByTripHeadSignRow struct {
	Lat             float64
	Lon             float64
	ShapePtSequence int64
}

func (q *Queries) GetShapesGroupedByTripHeadSign(ctx context.Context, arg GetShapesGroupedByTripHeadSignParams) ([]GetShapesGroupedByTripHeadSignRow, error) {
	rows, err := q.query(ctx, q.getShapesGroupedByTripHeadSignStmt, getShapesGroupedByTripHeadSign, arg.RouteID, arg.TripHeadsign)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShapesGroupedByTripHeadSignRow
	for rows.Next() {
		var i GetShapesGroupedByTripHeadSignRow
		if err := rows.Scan(&i.Lat, &i.Lon, &i.ShapePtSequence); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStop = `-- name: GetStop :one
SELECT
    id, code, name, "desc", lat, lon, zone_id, url, location_type, timezone, wheelchair_boarding, platform_code
FROM
    stops
WHERE
    id = ?
`

func (q *Queries) GetStop(ctx context.Context, id string) (Stop, error) {
	row := q.queryRow(ctx, q.getStopStmt, getStop, id)
	var i Stop
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Desc,
		&i.Lat,
		&i.Lon,
		&i.ZoneID,
		&i.Url,
		&i.LocationType,
		&i.Timezone,
		&i.WheelchairBoarding,
		&i.PlatformCode,
	)
	return i, err
}

const getStopIDsForAgency = `-- name: GetStopIDsForAgency :many
SELECT
    s.id
FROM
    stops s
`

func (q *Queries) GetStopIDsForAgency(ctx context.Context) ([]string, error) {
	rows, err := q.query(ctx, q.getStopIDsForAgencyStmt, getStopIDsForAgency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopIDsForRoute = `-- name: GetStopIDsForRoute :many
SELECT DISTINCT
    stop_times.stop_id
FROM
    stop_times
        JOIN trips ON stop_times.trip_id = trips.id
WHERE
    trips.route_id = ?
`

func (q *Queries) GetStopIDsForRoute(ctx context.Context, routeID string) ([]string, error) {
	rows, err := q.query(ctx, q.getStopIDsForRouteStmt, getStopIDsForRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stop_id string
		if err := rows.Scan(&stop_id); err != nil {
			return nil, err
		}
		items = append(items, stop_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopIDsForTrip = `-- name: GetStopIDsForTrip :many
SELECT DISTINCT
    stop_times.stop_id
FROM
    stop_times
WHERE
    stop_times.trip_id = ?
`

func (q *Queries) GetStopIDsForTrip(ctx context.Context, tripID string) ([]string, error) {
	rows, err := q.query(ctx, q.getStopIDsForTripStmt, getStopIDsForTrip, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stop_id string
		if err := rows.Scan(&stop_id); err != nil {
			return nil, err
		}
		items = append(items, stop_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopTimesByStopIDs = `-- name: GetStopTimesByStopIDs :many
SELECT
    trip_id, arrival_time, departure_time, stop_id, stop_sequence, stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint
FROM
    stop_times
WHERE
    stop_id IN (/*SLICE:stop_ids*/?)
`

func (q *Queries) GetStopTimesByStopIDs(ctx context.Context, stopIds []string) ([]StopTime, error) {
	query := getStopTimesByStopIDs
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StopTime
	for rows.Next() {
		var i StopTime
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.StopHeadsign,
			&i.PickupType,
			&i.DropOffType,
			&i.ShapeDistTraveled,
			&i.Timepoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopTimesForTrip = `-- name: GetStopTimesForTrip :many
SELECT
    trip_id, arrival_time, departure_time, stop_id, stop_sequence, stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint
FROM
    stop_times
WHERE
    trip_id = ?
ORDER BY
    stop_sequence
`

func (q *Queries) GetStopTimesForTrip(ctx context.Context, tripID string) ([]StopTime, error) {
	rows, err := q.query(ctx, q.getStopTimesForTripStmt, getStopTimesForTrip, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StopTime
	for rows.Next() {
		var i StopTime
		if err := rows.Scan(
			&i.TripID,
			&i.ArrivalTime,
			&i.DepartureTime,
			&i.StopID,
			&i.StopSequence,
			&i.StopHeadsign,
			&i.PickupType,
			&i.DropOffType,
			&i.ShapeDistTraveled,
			&i.Timepoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsByIDs = `-- name: GetStopsByIDs :many
SELECT
    id, code, name, "desc", lat, lon, zone_id, url, location_type, timezone, wheelchair_boarding, platform_code
FROM
    stops
WHERE
    id IN (/*SLICE:stop_ids*/?)
ORDER BY
    id
`

func (q *Queries) GetStopsByIDs(ctx context.Context, stopIds []string) ([]Stop, error) {
	query := getStopsByIDs
	var queryParams []interface{}
	if len(stopIds) > 0 {
		for _, v := range stopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", strings.Repeat(",?", len(stopIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:stop_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Desc,
			&i.Lat,
			&i.Lon,
			&i.ZoneID,
			&i.Url,
			&i.LocationType,
			&i.Timezone,
			&i.WheelchairBoarding,
			&i.PlatformCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsForRoute = `-- name: GetStopsForRoute :many
SELECT DISTINCT
    stops.id, stops.code, stops.name, stops."desc", stops.lat, stops.lon, stops.zone_id, stops.url, stops.location_type, stops.timezone, stops.wheelchair_boarding, stops.platform_code
FROM
    stop_times
    JOIN trips ON stop_times.trip_id = trips.id
    JOIN routes ON trips.route_id = routes.id
    JOIN stops ON stop_times.stop_id = stops.id
WHERE
    routes.id = ?
`

func (q *Queries) GetStopsForRoute(ctx context.Context, id string) ([]Stop, error) {
	rows, err := q.query(ctx, q.getStopsForRouteStmt, getStopsForRoute, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Desc,
			&i.Lat,
			&i.Lon,
			&i.ZoneID,
			&i.Url,
			&i.LocationType,
			&i.Timezone,
			&i.WheelchairBoarding,
			&i.PlatformCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsWithinBounds = `-- name: GetStopsWithinBounds :many
SELECT 
    id, code, name, "desc", lat, lon, zone_id, url, location_type, timezone, wheelchair_boarding, platform_code
FROM 
    stops
WHERE 
    lat >= ? AND lat <= ?
    AND lon >= ? AND lon <= ?
`

type GetStopsWithinBoundsParams struct {
	Lat   float64
	Lat_2 float64
	Lon   float64
	Lon_2 float64
}

func (q *Queries) GetStopsWithinBounds(ctx context.Context, arg GetStopsWithinBoundsParams) ([]Stop, error) {
	rows, err := q.query(ctx, q.getStopsWithinBoundsStmt, getStopsWithinBounds,
		arg.Lat,
		arg.Lat_2,
		arg.Lon,
		arg.Lon_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Desc,
			&i.Lat,
			&i.Lon,
			&i.ZoneID,
			&i.Url,
			&i.LocationType,
			&i.Timezone,
			&i.WheelchairBoarding,
			&i.PlatformCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrip = `-- name: GetTrip :one
SELECT
    id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM
    trips
WHERE
    id = ?
`

func (q *Queries) GetTrip(ctx context.Context, id string) (Trip, error) {
	row := q.queryRow(ctx, q.getTripStmt, getTrip, id)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.ServiceID,
		&i.TripHeadsign,
		&i.TripShortName,
		&i.DirectionID,
		&i.BlockID,
		&i.ShapeID,
		&i.WheelchairAccessible,
		&i.BikesAllowed,
	)
	return i, err
}

const getTripsByBlockID = `-- name: GetTripsByBlockID :many
SELECT
    id,
    route_id,
    service_id,
    trip_headsign,
    trip_short_name,
    direction_id,
    block_id,
    shape_id
FROM
    trips
WHERE
    block_id = ?
`

type GetTripsByBlockIDRow struct {
	ID            string
	RouteID       string
	ServiceID     string
	TripHeadsign  sql.NullString
	TripShortName sql.NullString
	DirectionID   sql.NullInt64
	BlockID       sql.NullString
	ShapeID       sql.NullString
}

func (q *Queries) GetTripsByBlockID(ctx context.Context, blockID sql.NullString) ([]GetTripsByBlockIDRow, error) {
	rows, err := q.query(ctx, q.getTripsByBlockIDStmt, getTripsByBlockID, blockID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTripsByBlockIDRow
	for rows.Next() {
		var i GetTripsByBlockIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsByBlockIDOrdered = `-- name: GetTripsByBlockIDOrdered :many
SELECT
    t.id,
    t.block_id,
    MIN(st.departure_time) AS first_departure_time
FROM
    trips t
    JOIN stop_times st ON st.trip_id = t.id
WHERE
    t.block_id = ?
GROUP BY
    t.id,
    t.block_id
ORDER BY
    MIN(st.departure_time)
`

type GetTripsByBlockIDOrderedRow struct {
	ID                 string
	BlockID            sql.NullString
	FirstDepartureTime interface{}
}

func (q *Queries) GetTripsByBlockIDOrdered(ctx context.Context, blockID sql.NullString) ([]GetTripsByBlockIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getTripsByBlockIDOrderedStmt, getTripsByBlockIDOrdered, blockID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTripsByBlockIDOrderedRow
	for rows.Next() {
		var i GetTripsByBlockIDOrderedRow
		if err := rows.Scan(&i.ID, &i.BlockID, &i.FirstDepartureTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTripsForRouteInActiveServiceIDs = `-- name: GetTripsForRouteInActiveServiceIDs :many
SELECT DISTINCT id, route_id, service_id, trip_headsign, trip_short_name, direction_id, block_id, shape_id, wheelchair_accessible, bikes_allowed
FROM trips t
WHERE t.route_id = ?1
  AND t.service_id IN (/*SLICE:('service_ids')*/?)
ORDER BY t.direction_id, t.trip_headsign
`

type GetTripsForRouteInActiveServiceIDsParams struct {
	RouteID    string
	ServiceIds []string
}

func (q *Queries) GetTripsForRouteInActiveServiceIDs(ctx context.Context, arg GetTripsForRouteInActiveServiceIDsParams) ([]Trip, error) {
	query := getTripsForRouteInActiveServiceIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.RouteID)
	if len(arg.ServiceIds) > 0 {
		for _, v := range arg.ServiceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:('service_ids')*/?", strings.Repeat(",?", len(arg.ServiceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:('service_ids')*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.ServiceID,
			&i.TripHeadsign,
			&i.TripShortName,
			&i.DirectionID,
			&i.BlockID,
			&i.ShapeID,
			&i.WheelchairAccessible,
			&i.BikesAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgencies = `-- name: ListAgencies :many
SELECT
    id, name, url, timezone, lang, phone, fare_url, email
FROM
    agencies
ORDER BY
    id
`

func (q *Queries) ListAgencies(ctx context.Context) ([]Agency, error) {
	rows, err := q.query(ctx, q.listAgenciesStmt, listAgencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agency
	for rows.Next() {
		var i Agency
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Timezone,
			&i.Lang,
			&i.Phone,
			&i.FareUrl,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutes = `-- name: ListRoutes :many
SELECT
    id,
    agency_id,
    short_name,
    long_name,
    "desc",
    type,
    url,
    color,
    text_color,
    continuous_pickup,
    continuous_drop_off
FROM
    routes
ORDER BY
    agency_id,
    id
`

func (q *Queries) ListRoutes(ctx context.Context) ([]Route, error) {
	rows, err := q.query(ctx, q.listRoutesStmt, listRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.AgencyID,
			&i.ShortName,
			&i.LongName,
			&i.Desc,
			&i.Type,
			&i.Url,
			&i.Color,
			&i.TextColor,
			&i.ContinuousPickup,
			&i.ContinuousDropOff,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertImportMetadata = `-- name: UpsertImportMetadata :one
INSERT
OR REPLACE INTO import_metadata (
    id,
    file_hash,
    import_time,
    file_source
)
VALUES
    (1, ?, ?, ?) RETURNING id, file_hash, import_time, file_source
`

type UpsertImportMetadataParams struct {
	FileHash   string
	ImportTime int64
	FileSource string
}

func (q *Queries) UpsertImportMetadata(ctx context.Context, arg UpsertImportMetadataParams) (ImportMetadatum, error) {
	row := q.queryRow(ctx, q.upsertImportMetadataStmt, upsertImportMetadata, arg.FileHash, arg.ImportTime, arg.FileSource)
	var i ImportMetadatum
	err := row.Scan(
		&i.ID,
		&i.FileHash,
		&i.ImportTime,
		&i.FileSource,
	)
	return i, err
}
